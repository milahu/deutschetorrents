#!/usr/bin/env python3

# generated by deepseek.com
"""
create a python script to modify github issues.
log in to github with an api token.
loop over all issues of a repo.
in the issue comments,
look for urls starting with "https:"
and ending with ".torrent".
download the torrent files
and replace each http link
with a magnet link in a markdown code fence.
use the "torf" library to handle torrent files.
in the torrent urls,
replace "erebus.feralhosting.com"
with "pontus.feralhosting.com".
read the github token
from the environment variable GITHUB_TOKEN.
process not just issue comments,
but also the issue body.
use `torf.Torrent.read_stream(b)`
to load the torrent bytes.
"""

import os
import sys
import requests
import re
import time
from urllib.parse import urlparse
import torf
import json

# Configuration
GITHUB_TOKEN = os.environ['GITHUB_TOKEN']  # Read from environment variable
REPO_OWNER = 'milahu'
REPO_NAME = 'deutschetorrents'
HEADERS = {
    'Authorization': f'token {GITHUB_TOKEN}',
    'Accept': 'application/vnd.github.v3+json'
}

def get_torrent(torrent_url):
    """Download torrent file and extract info hash using torf library"""
    try:
        response = requests.get(torrent_url, timeout=10)
        response.raise_for_status()
        
        # Parse torrent file with torf
        torrent = torf.Torrent.read_stream(response.content)
        return torrent
        
    except Exception as e:
        print(f"Error processing torrent {torrent_url}: {e}")
        return None

def replace_feral_domain(url):
    """Replace erebus.feralhosting.com with pontus.feralhosting.com"""
    return url.replace('erebus.feralhosting.com', 'pontus.feralhosting.com')

def torrent_to_magnet(torrent_url):
    """Convert torrent URL to magnet link"""
    # First replace the domain if needed
    torrent_url = replace_feral_domain(torrent_url)
    torrent = get_torrent(torrent_url)
    if not torrent:
        return None
    return str(torrent.magnet()) + f"&piece_size={torrent.piece_size}"

def process_text(text):
    """Find and replace torrent URLs in any text"""
    if not text:
        return None
    
    torrent_urls = re.findall(r'https?://[^\s]+\.torrent', text, re.IGNORECASE)
    
    # if not torrent_urls:
    #     return None
    
    updated_text = text[:]
    replacements = []
    
    for url in torrent_urls:
        print(f"Found torrent URL: {url}")
        magnet_link = torrent_to_magnet(url)
        if magnet_link:
            replacement = f"\n\n```\n{magnet_link}\n```\n\n"
            updated_text = updated_text.replace(url, replacement)
            replacements.append((url, magnet_link))
    
    # join code fences
    # updated_text = re.sub(r"```\n+```\nmagnet:", r"\nmagnet:", updated_text)
    # https://github.com/milahu/deutschetorrents/issues/18
    # updated_text = re.sub("```\n+```\nmagnet:", "\nmagnet:", updated_text)
    updated_text = re.sub(r"(\d+)\n```\n```\nmagnet:", r"\1\nmagnet:", updated_text)
    # remove double fences
    updated_text = re.sub(r"```\n+```", r"```", updated_text)
    # https://github.com/milahu/deutschetorrents/issues/12
    # updated_text = re.sub("\n+\nmagnet:", "\nmagnet:", updated_text)
    # remove download links
    updated_text = re.sub(r"https://erebus.feralhosting.com/milahu/Downloads/\S+/", r"", updated_text)
    
    #if not replacements:
    #    return None
    if text == updated_text:
        return None
    
    return {
        'text': updated_text,
        'replacements': replacements
    }

def update_issue(issue_number, new_body):
    """Update a GitHub issue body"""
    url = f'https://api.github.com/repos/{REPO_OWNER}/{REPO_NAME}/issues/{issue_number}'
    data = {'body': new_body}
    
    response = requests.patch(url, headers=HEADERS, json=data)
    response.raise_for_status()
    return response.json()

def update_comment(comment_id, new_body):
    """Update a GitHub comment"""
    url = f'https://api.github.com/repos/{REPO_OWNER}/{REPO_NAME}/issues/comments/{comment_id}'
    data = {'body': new_body}
    
    response = requests.patch(url, headers=HEADERS, json=data)
    response.raise_for_status()
    return response.json()

def get_all_issues():
    """Fetch all issues from the repository"""
    issues = []
    page = 1
    per_page = 100
    
    while True:
        url = f'https://api.github.com/repos/{REPO_OWNER}/{REPO_NAME}/issues?state=all&page={page}&per_page={per_page}'
        response = requests.get(url, headers=HEADERS)
        response.raise_for_status()
        
        batch = response.json()
        if not batch:
            break
            
        issues.extend(batch)
        page += 1
        
        # Respect GitHub's rate limits
        if 'X-RateLimit-Remaining' in response.headers and int(response.headers['X-RateLimit-Remaining']) < 10:
            reset_time = int(response.headers['X-RateLimit-Reset'])
            sleep_duration = max(reset_time - time.time(), 0) + 10
            print(f"Approaching rate limit. Sleeping for {sleep_duration} seconds.")
            time.sleep(sleep_duration)
    
    return issues

def get_issue_comments(issue_number):
    """Fetch all comments for an issue"""
    comments = []
    page = 1
    per_page = 100
    
    while True:
        url = f'https://api.github.com/repos/{REPO_OWNER}/{REPO_NAME}/issues/{issue_number}/comments?page={page}&per_page={per_page}'
        response = requests.get(url, headers=HEADERS)
        response.raise_for_status()
        
        batch = response.json()
        if not batch:
            break
            
        comments.extend(batch)
        page += 1
        
        # Respect GitHub's rate limits
        if 'X-RateLimit-Remaining' in response.headers and int(response.headers['X-RateLimit-Remaining']) < 10:
            reset_time = int(response.headers['X-RateLimit-Reset'])
            sleep_duration = max(reset_time - time.time(), 0) + 10
            print(f"Approaching rate limit. Sleeping for {sleep_duration} seconds.")
            time.sleep(sleep_duration)
    
    return comments

def main():
    print(f"Processing repository: {REPO_OWNER}/{REPO_NAME}")
    
    try:
        issues = get_all_issues()
        print(f"Found {len(issues)} issues to process")
        
        for issue in issues:
            issue_number = issue['number']
            print(f"\nProcessing issue {issue['html_url']} - {issue['title']}")
            if 0:
              print(json.dumps(issue, indent=2))
              sys.exit()
            # Process issue body
            body_result = process_text(issue['body'])
            if body_result:
                print(f"Updating issue #{issue_number} body")
                for old, new in body_result['replacements']:
                    print(f"  Replaced: {old}")
                    print(f"  With: {new}")
                
                try:
                    updated_issue = update_issue(issue_number, body_result['text'])
                    print("Issue body updated successfully")
                    
                    # sys.exit() # debug
                except Exception as e:
                    print(f"Failed to update issue body: {e}")
                
                time.sleep(1)
            
            # Process comments
            comments = get_issue_comments(issue_number)
            print(f"Found {len(comments)} comments in issue #{issue_number}")
            
            for comment in comments:
                comment_result = process_text(comment['body'])
                if comment_result:
                    print(f"Updating comment ID {comment['id']}")
                    for old, new in comment_result['replacements']:
                        print(f"  Replaced: {old}")
                        print(f"  With: {new}")
                    
                    try:
                        updated_comment = update_comment(comment['id'], comment_result['text'])
                        print("Comment updated successfully")
                    except Exception as e:
                        print(f"Failed to update comment: {e}")
                    
                    time.sleep(1)
    
    except Exception as e:
        print(f"Error: {e}")

if __name__ == '__main__':
    main()